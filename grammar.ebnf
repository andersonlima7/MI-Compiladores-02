<program> ::= <block>
<block> ::= <unlabelled-block> | <label> <block>
<unlabelled-block> ::= <block-head> "{" <block-tail> "}"
<block-head> ::= <declaration> | <block-head> ";" <declaration> 
<block-tail> ::= <statement> | <statement> ";" <block-tail>
<declaration> ::= <type-declaration> | <array-declaration>

program = {constant_declaration_block} {variable_declaration_block} {class} {objects_declaration_block} main_class 

main_class = "class" "main" "{" main_class_content "};"
main_class_content = {variable_declaration_block} {objects_declaration_block} {commands} 

# Definições de Variáveis e Constantes

variable_declaration_block = "variables" "{" variable_list "};"
variable_list = variable_declaration {";" variable_declaration}
variable_declaration = type id ["=" value] {"," id ["=" value]}

constant_declaration_block = "const" "{" constant_list "};"
constant_list = constant_declaration {";" constant_declaration}
constant_declaration = type id "=" value {"," id "=" value}

# Definição de Objetos

objects_declaration_block = "objects" "{" object_list "};"
object_list = object_declaration {";" object_declaration}
object_declaration = id id "=" "constructor(" parameter_list ")" {"," id "=" "constructor(" parameter_list ")"}
parameter_list = value {"," value}

# Expressões Condicionais e Relacionais

rel_expr := val_expr <relational operator> val_expr
log_expr := val_expr log_op val_expr | log_not

<boolean-expression> ::= <if-clause> <boolean-term>  "else" <boolean-expression>
<boolean-term> ::= <boolean-factor> | <boolean-term> "||" <boolean-factor>
<boolean-factor> ::= <boolean-secondary> | <boolean-factor> "&&" <boolean-secondary>
<boolean-secondary> ::= <boolean-primary> | "!" <boolean-primary>
<boolean-primary> ::= <boolean> | <variable> | "(" <boolean-expression> ")"
<conditional-statement> ::= <if-statement> | <if-statement> "else" <statement> | <if-clause> | <label> <conditional-statement>
<if-statement> ::= <if-clause> <unconditional-statement>
<if-clause> ::= "if" <boolean-expression> "then"
<unconditional-statement> ::= <basic-statement> | <block>
<basic-statement> ::= <unlabelled-basic-statement> | <label> <basic-statement> 
<unlabelled-basic-statement> ::= <assignment-statement>
<unsigned-integer> ::= <digit> | <unsigned-integer> <digit>
<statement> ::= <unconditional-statement> | <conditional-statement> | <for-command>
<label> ::= <id> | <unsigned-integer>

# Comandos

commands = for-command | print_command | read_command
<for-command> ::= 'for' '(' <expression> ';' <cond-expression> ';' {<expression>} ')'stmts
<print-command> ::= "print" "(" <expression> ")" ";"
<read-command> ::= "read" "(" <variable> ")" ";"

# Expressões

<expression> ::= <string> | <variable> | <number> | <boolean> | <method-call>
<method-call> ::= <identifier> "->" <identifier> "(" <argument-list> ")"
<argument-list> ::= <expression> | <expression> "," <expression>
val_expr := // Aqui residem outras expressões que se tornam valores, literais, etc.
<cond-expression> :=  <rel_expr> | <log_expr> | <boolean>

# Estrutura léxica da linguagem

id = letter {letter | digit | "_"};  # valid identifier
string_literal = '"'{letter | digit | symbol}'"'
number := digit { digit } [ '.' digit { digit } ]
<relational operator> ::= '!=' | '==' | '<' | '<=' | '>' | '>=' | '='
boolean := 'True' | 'False'
log_op := '&&' | '||'
log_not := '!' val_expr
array = "["[value {","value}]"]"
value = number | string_literal | boolean | array 
type = "int" {"[" digit "]"} | "real" {"[" digit "]"} | "string" {"[" digit "]"} | "boolean" {"[" digit "]"}
digit := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
letter := 'a'| 'b' | ... | 'z' | 'A' | 'B' | ... | 'Z'


# Definições de Classes

class = "class" , id , "{" , class-content , "}"
class-content = methods , constructor , variable_declaration_block

# Definições de Métodos

methods = "methods" , "{" , method-list , "}"
method-list = method , { method }
method = "void" | type , id , "(" , parameters , ")" , "{" , method-content , "}"
method-content = { statement }
parameters = param , { "," , param }
param = type , id
statement = "return" , value , ";"
constructor = "constructor" , "(" , parameters , ")" , "{" , constructor-content , "}"
constructor-content = { assignment }
assignment = "this" , "." , id, assignment-end;
assignment-end = ["=", assignment-value], ";"
assignment-value = id | value


